q()
# Load all of the packages that you end up using
# in your analysis in this code chunk.
# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.
library(ggplot2)
install.packages(ggplot2)
install.packages('ggplot2'')
install.packages('ggplot2')
install.packages('ggplot2'')
install.packages('ggplot2')
install.packages('dplyr')
install.packages('gridExtra')
install.packages('pander')
# Load all of the packages that you end up using
# in your analysis in this code chunk.
# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.
library(ggplot2)
library(dplyr)
library(gridExtra)
library(pander)
# Load the Data
redwine <- read.csv('wineQualityReds.csv')
str(redwine)
summary(redwine)
# quanlity的统计图
ggplot(data = redwine, aes(x = quality))+
geom_bar(color = 'black',fill = I('orange'))+
ggtitle("Quality Plot")
# 固定酸度的统计图
grid.arrange(ggplot(redwine, aes( x = 1, y = fixed.acidity ) ) +
geom_boxplot( color = 'red' )+
ylab('fixed.acidity(g/dm^3)'),
ggplot(data = redwine, aes(x = fixed.acidity)) +
xlab('fixed.acidity(g/dm^3)')+
geom_histogram(binwidth = 1, color = 'black',fill = I('orange')),ncol=2)
v1=1.8:3.8
v1
v2=1.8:4.2
v2
seq(1,9,length.out = 5)
seq(1,9,length.out = 10)
c(v1,v2)
v1=1.8:3.8
v2=1.8:4.2
seq(1,9,length.out = 5)
seq(1,9,length.out = 10)
c(v1,v2)
cbind(v1,v2)
cbind(v1,v2)
cbind(v1,v2)
v1=1.8:3.8
v2=1:3
seq(1,9,length.out = 5)
seq(1,9,length.out = 10)
c(v1,v2)
cbind(v1,v2)
rbind(v1,v2)
v1*2
v2+3
v1=1.8:3.8
v2=1:3
v1*2
v2+3
v2%/%3
v1=1.8:3.8
v2=1:3
v1*2
v2+3
### 整除
v2%/%3
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
mat
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
dim(mat)[1]
dim(mat)[2]
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#行名、列名
mat = matrix(c(1:16),nrow=4,ncol=4,byrow=TRUE)
#行名、列名
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
mat[-1,-2]
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
#删除第一行和第二列的数据再组合成新的矩阵
mat[-1,-2]
# 取矩阵元素
mat(1,2)
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
#删除第一行和第二列的数据再组合成新的矩阵
mat[-1,-2]
# 取矩阵元素
mat[1,2]
mat['a','b]
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
#删除第一行和第二列的数据再组合成新的矩阵
mat[-1,-2]
# 取矩阵元素
mat[1,2]
mat['a','b']
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
#删除第一行和第二列的数据再组合成新的矩阵
mat[-1,-2]
# 取矩阵元素
mat[1,2]
# 矩阵计算
3*mat
mat = matrix(c(2:16),nrow=4,ncol=4,byrow=TRUE)
dim(mat)
#取行数
dim(mat)[1]
#取烈数
dim(mat)[2]
#元素个数
length(mat)
#行名、列名
colnames(mat) = c('a','b','c','d')
rownames(mat) = c('e','f','g','h')
mat
#删除第一行和第二列的数据再组合成新的矩阵
mat[-1,-2]
# 取矩阵元素
mat[1,2]
# 矩阵计算
3*mat
mat*c(1:4)
# 转置
t(mat)
# 转置
t(mat)
mat%*%mat
# 转置
t(mat)
# 矩阵乘法
mat%*%mat
mat%*%c(1:4)
# 转置
t(mat)
# 矩阵乘法
mat%*%mat
mat%*%c(1:4)
# 求行列式
det(mat)
# 求对角线元素
diag(mat)
# 转置
t(mat)
# 矩阵乘法
mat%*%mat
mat%*%c(1:4)
# 求行列式
det(mat)
# 求对角线元素
diag(mat)
mat2 = matrix(rnorm(16),nrow=4)
solve(mat2)
colMeans(mat2)
rowMeans(mat2)
mat2 = matrix(rnorm(16),nrow=4)
# 求逆矩阵
solve(mat2)
# 求行、列的均值
colMeans(mat2)
rowMeans(mat2)
# 求行、列的和
colSums(mat2)
rowSums(mat2)
# 求标准差
sd(mat2)
getwd()
redwine <- read.csv('wineQualityReds.csv'，sep=",",header=T)
getwd()
data2 = data.frame(code=v1,value=v2)
redwine <- read.csv('wineQualityReds.csv',sep=",",header=T)
list1= list(vector=v1,matrix=mat2,data=data2)
list1= list(vector=v1,matrix=mat2,data=data2)
list1
data("iris")
attach("iris")
attach
attach(iris)
View(iris)
class = data.frame(c(1,2,3),as.vector(unique(iris[,5])))
names(class)=c("cla","name")
names
class
d = dist(iris[,-5],method= "euclidean",diag=T,upper=T,p=2)
hc = hclust(d,method="ward")
hc = hclust(d,method="ward.D")
plot(hc)
rt1 = data.frame(cutree(hc,k=3))
rt1 = data.frame(cutree(hc,k=3))
names(rt1) = "cla"
rt1 = merge(rt1,class,by="cla")
rc1
rt1
tab1 = table(rt1$name,iris[,5])
sum(diag(prop.table(tab1)))
diag(prop.table(tab1))
tab1 = table(rt1$name,iris[,5])
tab1
getwd()
setwd('C:\edwin\Document\Udacity ML\ML_advance\creating_customer_segments')
setwd('C:/edwin/Document/Udacity ML/ML_advance/creating_customer_segments')
getWd
getwd()
data = read.csv("customers.csv",sep=',',header=T)
data
r = round(cor(data),3)
r
r = round(cor(data[,-2]),3)
r
r = round(cor(data[2:]),3)
r = round(cor(data[2:,]),3)
r = round(cor(data[,2:]),3)
r = round(cor(data[,-1,-2]),3)
r
r = round(cor(data[,-:2]),3)
r = round(cor(data[,:2]),3)
data[2:]
data[:2]
data[,2:]
data[,2:-1]
data[,2:7]
data[,2:6]
data[,3:8]
r = round(cor(data[,3:8]),3)
r
pca = princomp(data[,3:8],cor=T)
summary(pca,loadings = T)
pre1 = round(pca,type = 'lines')
pre1 = round(pca,type = "lines")
pre1 = round(predict(pre1),3)
pre1 = round(predict(pca),3)
pca$scores
screeplot(pca,type="lines")
load = loadings(pca)
plot(load[,1:3])
abline(h=0)
abline(v=0)
score = as.matrix(pca$scores)
sd = as.vector(pca$sdev)
weight = sd^2/sum(sd^2)
tscore = score %*% weight
outcome = data.frame(pca$scores,tscore)
pca = princomp(data[,3:8],cor=F)
summary(pca,loadings = T)
screeplot(pca,type="lines")
loadings(pca)
r = round(cor(data[,3:8]),3)
r
pre1 = round(predict(pca),3)
pca$scores
a = princomp(data[,3:8],cor=T)
pca = princomp(data[,3:8],cor=T)
summary(pca,loadings = T)
pre1 = round(predict(pca),3)
pca$scores
load = loadings(pca)
plot(load[,1:3])
text(load[,1],load[,2],load[,3])
